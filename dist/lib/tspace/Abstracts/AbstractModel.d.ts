import { Relation, RelationQuery } from '../../Interface';
import { Builder } from '../Builder';
import { RelationHandler } from '../Handlers/Relation';
declare abstract class AbstractModel extends Builder {
    protected $relation: RelationHandler | undefined;
    protected abstract useUUID(): this;
    protected abstract usePrimaryKey(primaryKey: string): this;
    protected abstract useRegistry(): this;
    protected abstract useDebug(): this;
    protected abstract useTable(table: string): this;
    protected abstract useTablePlural(): this;
    protected abstract useTableSingular(): this;
    protected abstract useTimestamp(): this;
    protected abstract useSoftDelete(): this;
    protected abstract useHooks(functions: Function[]): this;
    protected abstract usePattern(pattern: string): this;
    protected abstract useCamelCase(pattern: string): this;
    protected abstract useSnakeCase(pattern: string): this;
    protected abstract useLoadRelationsInRegistry(): this;
    protected abstract useBuiltInRelationFunctions(): this;
    protected abstract define(): void;
    protected abstract hasOne({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract hasMany({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract belongsTo({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract belongsToMany({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract buildMethodRelation(name: string, callback?: Function): this;
    protected abstract hasOneBuilder({ name, model, localKey, foreignKey, freezeTable, as }: RelationQuery, callback: Function): this;
    protected abstract hasManyBuilder({ name, model, localKey, foreignKey, freezeTable, as }: RelationQuery, callback: Function): this;
    protected abstract belongsToBuilder({ name, model, localKey, foreignKey, freezeTable, as }: RelationQuery, callback: Function): this;
    protected abstract belongsToManyBuilder({ name, model, localKey, foreignKey, freezeTable, as, pivot }: RelationQuery, callback: Function): this;
    abstract ignoreSoftDelete(): this;
    abstract disableSoftDelete(): this;
    abstract registry(func: Record<string, Function>): this;
    abstract onlyTrashed(): this;
    abstract trashed(): this;
    abstract restore(): Promise<any[]>;
    abstract with(...nameRelations: string[]): this;
    abstract withQuery(nameRelations: string, callback: Function): this;
    abstract withExists(...nameRelations: string[]): this;
    abstract withTrashed(...nameRelations: string[]): this;
    abstract withAll(...nameRelations: string[]): this;
    abstract has(...nameRelations: string[]): this;
    abstract relations(...nameRelations: string[]): this;
    abstract relationQuery(nameRelations: string, callback: Function): this;
    abstract relationsExists(...nameRelations: string[]): this;
    abstract relationsAll(...nameRelations: string[]): this;
    abstract relationsTrashed(...nameRelations: string[]): this;
}
export { AbstractModel };
export default AbstractModel;
