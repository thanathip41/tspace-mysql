import { Pattern, Relation, RelationQuery, ValidateSchema } from '../../Interface';
import { Blueprint } from '../Blueprint';
import { Builder } from '../Builder';
import { RelationHandler } from '../Handlers/Relation';
import { Model } from '../Model';
declare abstract class AbstractModel<T, R> extends Builder {
    protected $relation: RelationHandler | undefined;
    protected $schema: Record<string, Blueprint> | undefined;
    protected $validateSchema: ValidateSchema | undefined;
    protected $table: string | undefined;
    protected $pattern: Pattern | undefined;
    protected $hasMany: RelationQuery[] | undefined;
    protected $hasOne: RelationQuery[] | undefined;
    protected $belongsTo: RelationQuery[] | undefined;
    protected $belongsToMany: RelationQuery[] | undefined;
    protected $timestamp: boolean | undefined;
    protected $softDelete: boolean | undefined;
    protected $uuid: boolean | undefined;
    protected $uuidColumn: string | undefined;
    protected $timestampColumns: {
        createdAt: string;
        updatedAt: string;
    } | undefined;
    protected $softDeleteColumn: string | undefined;
    protected $observer: (new () => {
        selected: Function;
        created: Function;
        updated: Function;
        deleted: Function;
    }) | undefined;
    protected abstract column<K extends keyof T>(key: K): K;
    protected abstract useUUID(): this;
    protected abstract usePrimaryKey(primaryKey: string): this;
    protected abstract useRegistry(): this;
    protected abstract useDebug(): this;
    protected abstract useTable(table: string): this;
    protected abstract useTablePlural(): this;
    protected abstract useTableSingular(): this;
    protected abstract useTimestamp(): this;
    protected abstract useSoftDelete(): this;
    protected abstract useHooks(functions: Function[]): this;
    protected abstract usePattern(pattern: string): this;
    protected abstract useCamelCase(pattern: string): this;
    protected abstract useSnakeCase(pattern: string): this;
    protected abstract useLoadRelationsInRegistry(): this;
    protected abstract useBuiltInRelationFunctions(): this;
    protected abstract define(): void;
    protected abstract hasOne({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract hasMany({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract belongsTo({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract belongsToMany({ name, model, localKey, foreignKey, freezeTable, as }: Relation): this;
    protected abstract buildMethodRelation<K extends keyof R>(name: K, callback?: Function): this;
    protected abstract hasOneBuilder({ name, model, localKey, foreignKey, freezeTable, as }: RelationQuery, callback: Function): this;
    protected abstract hasManyBuilder({ name, model, localKey, foreignKey, freezeTable, as }: RelationQuery, callback: Function): this;
    protected abstract belongsToBuilder({ name, model, localKey, foreignKey, freezeTable, as }: RelationQuery, callback: Function): this;
    protected abstract belongsToManyBuilder({ name, model, localKey, foreignKey, freezeTable, as, pivot }: RelationQuery, callback: Function): this;
    abstract ignoreSoftDelete(): this;
    abstract disableSoftDelete(): this;
    abstract registry(func: Record<string, Function>): this;
    abstract onlyTrashed(): this;
    abstract trashed(): this;
    abstract restore(): Promise<any[]>;
    abstract with<K extends keyof R>(...nameRelations: K[]): this;
    abstract withQuery<K extends keyof R, TModel extends Model>(nameRelations: K, callback: (query: TModel) => TModel): this;
    abstract withExists<K extends keyof R>(...nameRelations: K[]): this;
    abstract withTrashed<K extends keyof R>(...nameRelations: K[]): this;
    abstract withAll<K extends keyof R>(...nameRelations: K[]): this;
    abstract has<K extends keyof R>(...nameRelations: K[]): this;
    abstract relations<K extends keyof R>(...nameRelations: K[]): this;
    abstract relationQuery<K extends keyof R, TModel extends Model>(nameRelations: K, callback: (query: TModel) => TModel): this;
    abstract relationsExists<K extends keyof R>(...nameRelations: K[]): this;
    abstract relationsAll<K extends keyof R>(...nameRelations: K[]): this;
    abstract relationsTrashed<K extends keyof R>(...nameRelations: K[]): this;
}
export { AbstractModel };
export default AbstractModel;
